<!-- $Id: introduction.xml,v 1.9 2003-02-21 00:24:26 adam Exp $ -->
 <chapter id="introduction"><title>Introduction</title>

  <para>
   &yaz; is a C/C++ library for information retrieval applications
   using the Z39.50/SRW protocols for information retrieval.
  </para>

  <para>
   Properties of &yaz;:
   <itemizedlist>
    <listitem><para>
      Fast operation. The C based BER encoders/decoders as well
      as the server component of &yaz; is very fast.
     </para></listitem>
    <listitem><para>
      Complete 
      <ulink url="http://www.loc.gov/z3950/agency/">Z39.50</ulink>
      version 3 support. All newer extensions
      including Z39.50-2000 have been incorporated.
     </para></listitem>
    <listitem><para>
      Supports 
      <ulink url="http://www.loc.gov/z3950/agency/zing/srw/">SRW</ulink>
      version 1.0 (over HTTP and HTTPS).
     </para></listitem>
    <listitem><para>
      Includes BER encoders/decoders for the 
      <ulink url="http://www.nlc-bnc.ca/iso/ill/">ISO ILL</ulink>
      protocol.
     </para></listitem>
    <listitem><para>
      Supports the following transports: BER over TCP/IP
      (<ulink url="http://www.faqs.org/rfcs/rfc1729.html">RFC1729</ulink>),
      BER over unix local socket, and 
      <ulink url="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP
       1.1</ulink>.
     </para></listitem>
    <listitem><para>
      Secure Socket Layer support using
      <ulink url="http://www.openssl.org/">OpenSSL</ulink>.
      If enabled, &yaz; uses HTTPS transport (for SOAP) or
      "Secure BER" (for Z39.50).
     </para></listitem>
    <listitem><para>
      Offers 
      <ulink url="http://zoom.z3950.org/">ZOOM</ulink>
      C API implementing both Z39.50 and SRW.
     </para></listitem>
    <listitem><para>
      The &yaz; library offers a set of useful utilities
      related to the protocols, such as MARC (ISO2709) parser,
      CCL (ISO8777) parser, 
      <ulink url="http://www.loc.gov/z3950/agency/zing/cql/">CQL</ulink>
      parser, memory management routines, character set conversion.
     </para></listitem>
    <listitem><para>
      Portable code. &yaz; compiles out-of-the box on most Unixes and
      on Windows using Microsoft Visual C++.
     </para></listitem>
    <listitem><para>
      Liberal license that allows for commercial use of &yaz;.
     </para></listitem>
   </itemizedlist>
  </para>

  <sect1 id="introduction.reading"><title>Reading this Manual</title>
   <para>Most implementors only need to read a fraction of the
    material in thie manual, so a quick walkthrough of the chapters
    is in order.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <xref linkend="installation"/> contains installation 
      instructions for &yaz;. You don't need reading this
      if you expect to download &yaz; binaries.
      However, the chapter contains information about how
      to make <emphasis>your</emphasis> application link
      with &yaz;.
     </para>
    </listitem>

    <listitem>
      <para>
      <xref linkend="zoom"/> describes the ZOOM API of &yaz;.
      This is definitely worth a read if you wish to develop a Z39.50/SRW
     client.
    </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="zoom"/> describes the generic frontend server
      and explains how to develop server Z39.50/SRW applications for &yaz;.
     Obviously worth reading if you're to develop a server.
    </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="client"/> describes how to use the &yaz; Z39.50
      client. If you're developer and wish to test your server
      or a server from another party, you might find this chapter
      useful.
    </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="asn"/> documents the most commonly used Z39.50
      C data structures offered by the &yaz; API. Client
      developers using ZOOM you do not need reading this. 
      For the remaining client developers (not using ZOOM),
      reading this chapter is a must.
      Z39.50 server implementors should read this, unless you're 
      developing a simple server (or SRW only).
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="tools"/> contains sections for the various
      tools offered by &yaz;. Scan through the material quickly
      and see what's relevant to you! SRW implementors
      might find the <link linkend="tools.cql">CQL</link> section
      particularly useful.
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="odr"/> goes through the details of the
      ODR module which is the work horse that encodes and decodes
      BER packages. Implementors using ZOOM only do not need reading this.
      Most other Z39.50 implementors only need to read the first two
      sections <link linkend="odr.introduction">Introduction</link>,
      <link linkend="odr.use">Using ODR</link>.
     </para>
    </listitem>

    <listitem>
     <para>
      <xref linkend="comstack"/> describes the network layer module
      COMSTACK. Implementors using ZOOM or the generic frontend server
      may skip this. Others, presumably, handling client/server
     communication on their own should read this.
     </para>
    </listitem>

   </itemizedlist>
  </sect1>
  <sect1 id="introduction.api"><title>The API</title>
   
   <para>
    The <ulink url="http://www.indexdata.dk/yaz/">&yaz;</ulink>
    toolkit offers several different levels of access to the
    <ulink url="http://www.loc.gov/z3950/agency/">ISO23950/Z39.50</ulink>,
    <ulink url="http://www.nlc-bnc.ca/iso/ill/">ILL</ulink> and
    SRW protocols.
    The level that you need to use depends on your requirements, and
    the role (server or client) that you want to implement.
    If you're developing a client application you should consider the
    <link linkend="zoom">ZOOM</link> API.
   It is, by far, the easiest way to develop clients in C.
    Server implementers should consider the 
    <link linkend="server">generic frontend server</link>.
    None of those high-level APIs support the whole protocol, but
    they do include most facilities used in existing Z39.50
    applications.
   </para>
   <para>
    If you're using 'exotic' functionality (meaning anything not included in
    the high-level APIs), developing non-standard extensions to Z39.50 or
    you're going to develop an ILL application you'll have to learn the lower
    level APIs of &yaz;.
   </para>
  <para>
    The basic low level modules, which are independent of the role
    (client or server), consist of three primary interfaces:
    
    <itemizedlist>
     <listitem><para>&asn;, which provides a C representation of the Z39.50
       protocol packages (PDUs).
      </para></listitem>
     <listitem><para>&odr;, which encodes and decodes the packages according
       to the BER specification.
      </para></listitem>
     <listitem><para>&comstack;, which exchanges the encoded packages with
       a peer process over a network.
      </para></listitem>
    </itemizedlist>
    
    The &asn; module represents the ASN.1 definition of
    the Z39.50 protocol. It establishes a set of type and
    structure definitions, with one structure for each of the top-level
    PDUs, and one structure or type for each of the contained ASN.1 types.
    For primitive types, or other types that are defined by the ASN.1
    standard itself (such as the EXTERNAL type), the C representation is
    provided by the &odr; (Open Data Representation) subsystem.
  </para>
   <para>
     &odr; is a basic mechanism for representing an
    ASN.1 type in the C programming language, and for implementing BER
    encoders and decoders for values of that type. The types defined in
    the &asn; module generally have the prefix <literal>Z_</literal>, and
    a suffix corresponding to the name of the type in the ASN.1
    specification of the protocol (generally Z39.50-1995). In the case of
    base types (those originating in the ASN.1 standard itself), the prefix
    <literal>Odr_</literal> is sometimes seen. Either way, look for
    the actual definition in either <filename>z-core.h</filename> (for the types
    from the protocol), <filename>odr.h</filename> (for the primitive ASN.1
    types).
    The &asn; library also provides functions (which are, in turn,
    defined using &odr; primitives) for encoding and decoding data values.
    Their general form is
    
    <funcsynopsis>
     <funcprototype><funcdef>int <function>z_<replaceable>xxx</replaceable></function></funcdef>
      <paramdef>ODR <parameter>o</parameter></paramdef>
      <paramdef>Z_<replaceable>xxx</replaceable> **<parameter>p</parameter></paramdef>
      <paramdef>int <parameter>optional</parameter></paramdef>
      <paramdef>const char *<parameter>name</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    (note the lower-case &quot;z&quot; in the function name)
   </para>
   
   <note>
    <para>
     If you are using the premade definitions of the &asn; module, and you
     are not adding new protocol of your own, the only parts of &odr; that you
     need to worry about are documented in section 
     <link linkend="odr-use">Using ODR</link>.
    </para>
   </note>
   
  <para>
    When you have created a BER-encoded buffer, you can use the &comstack;
    subsystem to transmit (or receive) data over the network. The &comstack;
    module provides simple functions for establishing a connection
    (passively or actively, depending on the role of your application),
    and for exchanging BER-encoded PDUs over that connection. When you
    create a connection endpoint, you need to specify what transport to
    use (TCP/IP, SSL or UNIX sockets).
    For the remainder of the connection's lifetime, you don't have
   to worry about the underlying transport protocol at all - the &comstack;
    will ensure that the correct mechanism is used.
   </para>
   <para>
    We call the combined interfaces to &odr;, &asn;, and &comstack; the service
    level API. It's the API that most closely models the Z39.50
   service/protocol definition, and it provides unlimited access to all
    fields and facilities of the protocol definitions.
   </para>
   <para>
    The reason that the &yaz; service-level API is a conglomerate of the
   APIs from three different submodules is twofold. First, we wanted to allow
    the user a choice of different options for each major task. For instance,
    if you don't like the protocol API provided by &odr;/&asn;, you
    can use SNACC or BERUtils instead, and still have the benefits of the
    transparent transport approach of the &comstack; module. Secondly,
    we realize that you may have to fit the toolkit into an existing
    event-processing structure, in a way that is incompatible with
    the &comstack; interface or some other part of &yaz;.
   </para>
  </sect1>
 </chapter>

 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:"yaz.xml"
 sgml-local-catalogs: nil
 sgml-namecase-general:t
 End:
 -->
